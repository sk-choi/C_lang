// 포인터끼리 대입 연산을 수행하면 여러 개의 포인터로 같은 데이터를 다루는 것이 가능.
// 그러나 규칙을 지키지 않는 대입 연산은 그 결과를 예상할 수 없음

#include <stdio.h>

int main(void)
{
	int a = 10;
	int* p = &a;
	double* pd;

	pd = p;
	printf("%lf\n", *pd);

	return 0; 


}

// 변수 p와 pd는 모두 포인터지만 가리키는 자료형이 다르다.
// 즉, 컴파일러는 p에 저장된 값을 int형 변수의 주소로 생각하고, 
// pd에 저장된 값을 double형 변수의 주소로 생각.
// 따라서 pd에 p를 대입한 후에 간접 참조 연산을 수행하면 
// 변수 a에 할당된 영역 이후의 할당되지 않은 영역까지 사용하게 된다.

// 포인터의 대입 규칙
// 1. 포인터는 가리키는 변수의 형태가 같을 때만 대입해야 한다.
// 2. 형 변환을 사용한 포인터의 대입은 언제나 가능하다.

//double a = 3.4;
//double pd = &a;
//int* pi;
//pi = (int*)pd;

// 여기서 pi에 간접 참조 연산을 수행하면 변수 a의 일부를 int형 변수처럼 사용할 수 있다.
// 이런 사용 방법은 포인터로 메모리를 직접 쪼개 쓰는 것으로 데이터가 메모리에 저장되는 방식을 이해해야 한다.
// *pi = 10과 같이 a의 일부분에 정수를 저장하면 정수와 실수의 데이터 크기와 저장방식이 다르므로 a에 저장한 실수 값은 사용할 수 없다.

