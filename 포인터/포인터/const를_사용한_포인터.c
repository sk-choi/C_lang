// const 예약어를 포인터에 사용하면 이는 가리키는 변수의 값을 바꿀 수 없다는 의미.
// 변수에 사용하는 것과는 다른 의미를 가진다.

#include <stdio.h>

int main(void)
{
	int a = 10, b = 20;
	const int* pa = &a; //포인터 pa는 변수 a를 가리킨다.

	printf("변수 a의 값 : %d\n", *pa); // 포인터를 간접 참조해 a 출력
	pa = &b; // 포인터가 변수 b를 가리키게 한다.
	printf("변수 b의 값 : %d\n", *pa); // 포인터를 간접 참조해 b값 출력
	pa = &a; // 포인터가 다시 변수 a를 가리킨다.
	a = 20; // a를 직접 참조해 값을 바꾼다.
	printf("변수 a의 값 : %d\n", *pa); // 포인터로 간접 참조해 바뀐 값 출력

	return 0;
}

// 포인터 pa를 const로 상수화 했는데, 만약 const가 일반 변수처럼 포인터 값을 고정시킨다면
// pa는 다른 변수의 주소를 저장할 수 없다.
// 그러나 출력 결과에서 pa는 const의 사용과 무관하게 변수 b의 주소를 저장하고 그 값을 간접 참조해 출력.

// 포인터에 사용된 const의 의미는...?
// 바로 pa가 가리키는 변수 a는 pa를 간접 참조해 바꿀 수 없다는 것.
// 즉 *pa = 20;과 같이 pa를 통해 a 값을 바꾸고자 한다면 에러메세지 출력.

// 포인터에 const를 사용하는 대표적인 예는 문자열 상수를 인수로 받는 함수.
// 문자열 상수는 값이 바뀌면 안되므로 함수의 매개변수를 통해서 값을 바꿀 수 없도록
// 매개변수에 선언된 포인터에 const를 사용.ㄴ