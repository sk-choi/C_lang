// 메모리의 주소는 필요할 때마다 계속 주소 연산을 수행하는 것보다
// 한 번 구한 주소를 저장해서 사용하면 편리한데
// 포인터가 바로 변수의 메모리 주소를 저장하는 변수이다.
// 따라서 주소를 저장할 포인터도 변수처럼 선언하고 사용
// 선언할 때는 변수 앞에 *만 붙여주면 된다.

#include <stdio.h>

int main(void)
{
	int a; //일반 변수 선언
	int* pa; // 포인터 선언

	pa = &a; //포인터에 a의 주소 대입
	*pa = 10; //포인터로 변수 a에 10 대입

	printf("포인터로 a값 출력 : %d\n", *pa);
	printf("변수명으로 a 값 출력 : %d\n", a);

	return 0;
}

// 포인터 변수가 선언되면 일반 변수와 마찬가지로 메모리에 저장 공간이 할당되고 그 이후에는 변수명으로 사용할 수 있음.
// 이제 포인터 pa는 변수 a가 메모리 어디에 할당되었는지 그 위치를 기억하고 있는데
// 이렇게 포인터가 어떤 변수의 주소를 저장한 경우 '가리킨다'고 말하며 둘의 관계를 pa -> a처럼 화살표로 간단히 표현한다.
// 반대로 x -> y로 표현한다면 'x는 y를 가리킨다'고 말할 수 있고
// x는 포인터이며 변수 y의 주소를 저장하고 있다는 뜻

// 포인터가 어떤 변수를 가리키면 포인터로 가리키는 변수를 사용할 수 있다.
// 즉, 포인터 pa로 변수a를 사용할 수 있다.
// 포인터가 가리키는 변수를 사용할 때는 포인터에 특별한 연산자를 사용하는데,
// 이를 간접 참조 연산자(*)또는 포인터 연산자라고 한다.

// 즉, pa == a이다.

// *pa는 변수 a의 쓰임과 마찬가지로 대입 연산자(=)의 왼쪽에 올 때는 pa가 가리키는 변수의 저장 공간(l-value)으로 사용되고
// 오른쪽에 올 때는 pa가 가리키는 변수의 값(r-value)으로 사용된다.

// 입력할 때 생각해 볼 문제가 있는데,
// scanf 함수를 사용하려면 입력할 변수가 메모리 어디에 할당되었는지, 즉 저장 공간의 위치를 알아야 한다.
// 따라서 입력할 변수의 주소를 인수로 줘야 한다. (scanf("%d\n", &a)인 이유)
// 포인터 pa를 통해 변수 a에 입력할 때도 마찬가지이다.
// *pa는 a와 같으므로 &a는 &*pa와 같다.
// 즉, 간접 참조 연산자(*)로 pa가 가리키는 변수를 구하고 다시 주소 연산자(&) 로 주소를 구한다.
// 그런데 pa가 a의 주소를 저장하고 있으므로 바로 pa를 사용해도 된다.

