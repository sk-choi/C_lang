// 배열은 자료형이 같은 변수를 메모리에 연속으로 할당한다.
// 각 배열요소는 일정한 간격으로 주소를 갖게 됨.
// 예를 들어 int ary[5];의 배열이 메모리 100번지부터 할당되고
// int형 변수의 크기가 4바이트라면 각 배열 요소의 주소는 100,104,108,112,116 번지가 된다.

// 결국 첫번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알 수 있고
// 각 주소에 간접 참조 연산을 수행하면 모든 배열 요소를 사용할 수 있다.
// 컴파일러는 첫 번째 배열 요소의 주소를 쉽게 사용하도록 배열명을 컴파일 과정에서 첫 번째 배열 요소의 주소로 변경.

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
	int ary[3];
	int i;

	*(ary + 0) = 10; // ary[0] = 10
	*(ary + 1) = *(ary + 0) + 10; // ary[1] = ary[0]+10, 주소 + 정수 -> 주소 + (정수 * 주소를 구한 변수의 크기)이므로 
								 //ary[0]의 주소가 만약 100부터 시작한다면, 위의 연산을 통해서 104번지 주소에 값이 할당됨. 
								// 즉, ary[1]의 값이 ary[0]의 값 + 10인 20이 되는 것. 

	printf("세 번째 배열 요소에 키보드 입력 : ");
	scanf("%d", ary + 2); // &ary[2]

	for (i = 0; i < 3; i++) // 모든 배열 요소 출력
	{
		printf("%5d", *(ary + i)); // ary[i]
	}

	return 0;
}

// 주소는 정수처럼 보이지만 자료형에 관한 정보를 갖고 있는 특별한 값.
// 따라서 연산을 자유롭게 할 수 없고 정해진 연산만 가능.
// 정수 덧셈이 대표적.
// 주소 + 정수 -> 주소 + (정수 * 주소를 구한 변수의 크기)

// 이런 연산 규칙은 배열을 사용할 때 유용한데, 배열명도 주소이므로 정수를 차례대로 더하면 연속된 배열 요소의 주소를 구할 수 있고.
// 여기에 간접 참조 연산을 수행하면 모든 배열요소를 사용할 수 있다.