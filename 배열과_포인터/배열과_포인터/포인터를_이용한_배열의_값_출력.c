#include <stdio.h>

int main(void)
{
	int ary[3] = { 10,20,30 };
	int* pa = ary;
	int i;

	printf("배열의 값 : ");
	for (i = 0; i < 3; i++)
	{
		printf("%d ", *pa); // pa가 가리키는 배열 요소 출력
		pa++; // 다음 배열 요소를 가리키도록 pa값 증가
	}

	return 0;
}

// 포인터 pa로 첫 번째 배열 요소를 출력하는 3가지 방법.
// 방법1. pa를 배열명처럼 사용해 첫 번째 배열 요소를 출력하는 방법.
// ex. printf("%d", pa[0]);
// 방법2. pa[0]을 그대로 포인터 연산식으로 바꾸는 방법.
// ex. printf("%d", *(pa + 0));
// *(pa + 0)에서 의미 없는 0과 괄호를 제거하는 방법.
// printf("%d", *pa);

// 표현 방법은 다르지만 모두 첫 번째 배열 요소를 출력한다. 
// 마지막 방법의 경우 pa는 첫 번째 배열 요소를 가리키므로 *pa의 연산식으로 첫 번째 배열 요소의 값을 출력.
// 두 번째 배열 요소의 값 출력: pa에 1을 더하면 두 번째 배열 요소의 주소 104번지가 되므로 이 값을 다시 pa에 저장하면 된다.
// ex. pa = pa + 1; or pa++;

// 세 번째 배열 요소도 같은 방식으로 pa의 값을 증가시키면 된다.
// 포인터 pa가 변수이므로 그 값을 바꿀 수 있기 때문에 모든 배열요소를 출력할 수 있는 것.
// 아래와 같이 포인터로 배열 요소를 차례로 출력할 때 증가 연산자와 간접 참조 연산자를 함께 사용하는 방법도 존재.

//for (i = 0; i < 3; i++)
//{
//	printf("%d ", *(pa++)); //후위형 사용
//}

// 연산자 우선 순위에 따라 pa++가 먼저 수행되므로 pa의 값은 증가.
// 그러나 후위형이기 때문에 다음 연산인 간접 참조 연산을 수행할 때는 증가되기 이전의 값이 사용됨.
// 컴파일러는 pa가 증가되기 이전 값을 임시공간에 저장해 두었다가 간접 참조 연산에 사용.
// 혹은 연산자 우선순위를 바꾸어 pa++보다 *pa의 연산을 먼저 수행하도록 컴파일.
// 컴파일러가 어떤 방식을 사용하든 결국 pa가 가리키던 배열 요소의 값이 먼저 출력되고 pa가 다음 배열 요소를 가리키는 것과 결과는 같다.

// 주의 1. 포인터는 값이 변할 수 있으므로 유효한 값인지 확인하는 습관이 필요.
// 주의 2. 포인터에 증가 연산자와 간접 참조 연산자를 함께 사용할 때 전위 표현을 사용하면 안된다.
// 전위 표현을 사용하면 예를 들어 (*pa++)의 경우 pa의 값이 먼저 증가된 후에 증가된 pa가 가리키는 배열 요소를 
// 간접 참조하므로 두 번째 배열 요소부터 출력됨.
// 또한 전위형이나 후위형 모두 괄호를 생략해도 결과는 같다.
// 간접 참조 연산자와 증가 연산자는 모두 단항 연산자로
// 우선순위가 같고 이 경우 연산 방향은 오른쪽에서 왼쪽...항상 증가 연산자가 먼저 수행됨.

