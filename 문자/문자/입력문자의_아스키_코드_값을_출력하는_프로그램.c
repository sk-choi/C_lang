// scanf 함수는 키보드로 ctrl + z를 누르면 -1을 반환
// ctrl + z을 누르고 ctrl + z를 한 번 더 입력해야 -1이 반환될 수 있음.
// 유닉스나 리눅스 시스템에서는 ctrl + d를 사용
// 결국 scanf 함수가 -1을 반환하기 전까지 반복 입력하면 개행문자를 포함한 모든 문자를 데이터로 사용할 수 있음.


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
	int res; // scanf 함수의 반환값을 저장할 변수
	char ch; // 문자를 입력할 변수

	while (1)
	{
		res = scanf("%c", &ch); // 문자 입력, ctrl + z를 누르면 -1 반환
		if (res == -1) break; // 반환값이 -1이면 반복 종료
		printf("%d ", ch); // 입력된 문자의 아스키 코드 값 출력
	}

	return 0;
}

// 실행결과의 입출력은 enter를 기준으로 반복됨.
// 첫 번째 행의 입력은 두 번째 행에서 아스키 코드 값을 출력하고 새로운 입력을 기다림.
// 입력한 데이터는 enter를 누르는 순간 버퍼로 저장됨.
// 반복문이 수행되면서 버퍼의 문자를 하나씩 가져다 아스키 코드 값을 출력.
// 버퍼의 데이터를 모두 처리하면 다시 키보드로부터 새로운 데이터를 입력 받기 위해 대기 상태가 된다.
// 마지막으로 ctrl + z를 누르면 scanf 함수는 -1을 반환하고 if문의 조건식이 참이 되어 반복을 종료.


// 키보드로 숫자를 입력하는 경우에도 일단 문자열의 형태로 버퍼에 저장됨.
// 그 후에 문자열이 실제 연산이 가능한 값으로 변환되어 변수에 저장됨.
// 예를 들어 int형 변수 a에 20을 입력하는 경우 문자 '2'와 '0'이 각각 아스키 코드 값으로 코드화 되어 버퍼에 저장됨.
// 그 후 변환문자의 지시에 따라 연산이 가능한 숫자로 변환되어 변수에 저장됨.

// 결국 변환문자는 코드화된 문자열을 숫자로 변환하는 방법을
// scanf 함수에 알려주는 역할을 함.
// 만약 같은 입력에 대해 %lf 변환 문자를 쓰고 실수형 변수에 입력한다면
// 버퍼에 저장된 상태는 같지만 IEEE 754 표준에 따라 변환되므로 변수에 저장되는 비트열의 크기와 형태는 달라짐.


