// 컴파일러는 'a'를 문자 상수로 해석.
// 문자 상수 'a'는 정수 값 97로 해석.
// 결국 문자는 메모리에 저장되는 방식이 정수와 같다. 따라서 int형 변수에 저장하고 정수처럼 연산할 수 있다.
// 즉, 문자 'a'를 %d로 출력하면 97을 출력하고
// 정수 97을 %c로 출력하면 아스키 코드 값인 97인 문자를 출력한다. 
// 결론적으로 문자 상수 'a'와 정수 97은 같은 데이터. 변환 문자열의 종류에 따라 출력 형태가 결정됨.

// 아스키 코드의 특징.

// 알파벳과 숫자는 각각 연속된 아스키 코드 값을 갖는다.
// 소문자가 대문자보다 아스키 코드 값이 크다.
// 제어 문자는 백슬래시와 함께 표시하며 출력할 때 그 기능을 수행한다.


#include <stdio.h>

int main(void)
{
	char small, cap = 'G'; // char형 변수 선언과 초기화

	if ((cap >= 'A') && (cap <= 'Z')) // 대문자 범위라면
	{
		small = cap + ('a' - 'A'); // 대/소문자의 차이를 더해 소문자로 변환
	}

	printf("대문자 : %c %c", cap, '\n'); // '\n' 를 %c로 출력하면 줄이 바뀐다.
	printf("소문자 : %c", small);

	return 0;
}

// 문자 상수는 4바이트의 크기를 갖지만 아스키 코드 값이 0~127의 범위에 있으므로 
// 2진수로 바꾸면 왼쪽 3바이트는 모두 0이 되고 오른쪽 1바이트만 의미를 갖는다.
// 따라서 문자는 1바이트 크기의 char형 변수에 저장해 사용할 수 있다.
// 컴파일러는 문자에서 아스키 코드 값을 갖는 오른쪽 1바이트만 변수에 저장하고 남는 바이트는 버림.
// ex. 00000000 00000000 00000000 01000111에서 앞의 3바이트는 저장할 공간이 없으니 버려짐.

// 23행에서 cap에 저장된 대문자를 소문자로 바꾸어 변수 small에 저장. (소문자에서 대문자를 뺀 차를 활용)
// 소문자는 대문자보다 아스키 코드 값이 크고 같은 문자끼리는 아스키 코드 값의 차가 일정.
// 'a'-'A'의 값을 대문자 'G'에 더하면 소문자 'g'를 구할 수 있음.

// 26행에선 제어 문자를 프로그램에서 상수로 쓸 때는 백슬래시와 제어 기능을 암시하는 문자를 함께 사용.
// 즉, 줄을 바꾸는 문자는 new line의 n을 따서 '\n'와 같이 표현한다.
// 제어문자는 형태가 없으므로 %c로 출력하면 해당 제어기능이 수행.
