#include <stdio.h>

int main(void)
{
	printf("%c\n", 'A'); //문자 상수 출력 'c'사용
	printf("%s\n", "A"); //문자열 상수 출력 's'사용
	printf("%c은 %s입니다.\n", '1', "first"); //문자(%c)와 문자열(%s)을 함께 출력, 1은 문자, first는 문자열

	return 0;
}
//<상수가 컴파일된 후의 비트 형태>
//비트는 0과 1의 두가지, byte는 비트 8개 모인 것(2^8)
//정수:4 byte, 32 bit (2진수)
//실수:8 byte, 64 bit (IEEE 754 표준 double형)
//문자:4 byte, 32 bit (아스키 코드 값과 같은 2진수)
//예를 들어서 문자 'A'가 컴파일된다면 'A'의 아스키 코드 값에 해당하는 65로 변환된다. 결국 문자 상수는 컴퓨터 안에서 정수와 같은 방식으로 처리됨.

//<정수 상수가 컴파일된 후의 형태>
//정수는 0을 포함한 양수와 음수로 나뉨.

//<양수의 변환>
//정수를 컴파일 하면 4바이트 크기의 2진수로 변환됨. 예를 들어 13은 13의 2진수인 1101로 변환됨.
//이렇게 본다면 모든 비트가 1일 때 가장 큰 값이 되는데, 1비트에서 가장 큰 값은 1이지만, 8비트에서 가장 큰 값은 255가 된다. 그리고 32비트에서 가장 큰 값은 4294967295가 된다.
//4294967295보다 큰 값을 처리할 때 컴파이러는 자동으로 크기를 8바이트로 늘려 처리함.
//값의 크기와 상관없이 데이터의 크기를 8바이트로 만들고 싶을 때는 LL이나 ll을 붙여 사용하면 된다.

//<음수의 변환>
//음수는 절댓값을 2의 보수로 바꾸어서 처리한다. 2의 보수란 0과 1을 바꾼 상태에서 1을 더한 값을 말함. 
//예를 들어 -10은 그 절댓값인 10을 2진수로 바꾸고 1의 보수를 구한 후에 다시 1을 더해서 만든 것.
//결과적으로 10과 -10의 모든 비트를 더하면 값이 0이 됨.

//<실수 상수가 컴파일된 후의 비트 형태>
//실수는 제한된 데이터 크기에 수를 표현하기 위해 IEEE 754 표준을 따른다. (이 표준에는 single, double, quad의 세 가지가 존재)
//double은 실수를 8바이트(64비트)로 표현하며 부호비트 1비트, 지수부 11비트와 소수부 52비트로 나누어 표현한다.
//실수 상수의 경우 표현할 수 있는 값의 범위가 넓지만, 정확하게 표현하는 데에는 한계가 존재한다.
//즉 오차가 발생하는데, 이는 소수 부분을 비트가 정확하게 표현할 수 없기 때문이다.
//결론적으로 IEEE 754 표준 계산식에 의하면 double형의 경우 15자리까지 유효숫자를 사용할 수 있다.